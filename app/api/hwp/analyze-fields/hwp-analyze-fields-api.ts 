// app/api/hwp/analyze-fields/route.ts
import { NextResponse } from 'next/server';

interface AnalyzedField {
  id: string;
  label: string;
  type: 'text' | 'number' | 'date' | 'table' | 'checkbox' | 'textarea';
  required: boolean;
  maxLength?: number;
  placeholder?: string;
  description?: string;
  category: string;
  priority: number;
  validation?: string;
}

interface FieldAnalysisResult {
  success: boolean;
  fileName: string;
  totalFields: number;
  fields: AnalyzedField[];
  sections: Array<{
    id: string;
    title: string;
    fields: string[];
  }>;
  confidence: number;
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { extractedText, fileName, method } = body;
    
    if (!extractedText) {
      return NextResponse.json(
        { error: 'ë¶„ì„í•  í…ìŠ¤íŠ¸ê°€ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤' },
        { status: 400 }
      );
    }
    
    console.log('ğŸ” HWP í•„ë“œ ë¶„ì„ ì‹œì‘:', fileName);
    console.log('ì¶”ì¶œ ë°©ë²•:', method);
    console.log('í…ìŠ¤íŠ¸ ê¸¸ì´:', extractedText.length);
    
    // 1. í…ìŠ¤íŠ¸ ì „ì²˜ë¦¬
    const cleanedText = preprocessText(extractedText);
    
    // 2. ì„¹ì…˜ êµ¬ë¶„
    const sections = identifySections(cleanedText);
    
    // 3. í•„ë“œ íŒ¨í„´ ì¸ì‹
    const fields = identifyFields(cleanedText, sections);
    
    // 4. í•„ë“œ ë¶„ë¥˜ ë° ìš°ì„ ìˆœìœ„ ì„¤ì •
    const categorizedFields = categorizeFields(fields);
    
    // 5. ê²€ì¦ ê·œì¹™ ì¶”ê°€
    const validatedFields = addValidationRules(categorizedFields);
    
    const result: FieldAnalysisResult = {
      success: true,
      fileName: fileName || 'unknown.hwp',
      totalFields: validatedFields.length,
      fields: validatedFields,
      sections: sections,
      confidence: calculateConfidence(extractedText, validatedFields, method)
    };
    
    console.log(`âœ… í•„ë“œ ë¶„ì„ ì™„ë£Œ: ${validatedFields.length}ê°œ í•„ë“œ, ${sections.length}ê°œ ì„¹ì…˜`);
    
    return NextResponse.json(result);
    
  } catch (error) {
    console.error('í•„ë“œ ë¶„ì„ ì˜¤ë¥˜:', error);
    return NextResponse.json(
      { 
        success: false,
        error: 'í•„ë“œ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
        details: error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'
      },
      { status: 500 }
    );
  }
}

function preprocessText(text: string): string {
  return text
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .replace(/\n+/g, '\n')
    .replace(/\s+/g, ' ')
    .trim();
}

function identifySections(text: string) {
  const lines = text.split('\n');
  const sections = [];
  
  const sectionPatterns = [
    { pattern: /^\d+\.\s*(.+)/, type: 'numbered' },
    { pattern: /^[ê°€-í£]\.\s*(.+)/, type: 'korean_letter' },
    { pattern: /^\([ê°€-í£]\)\s*(.+)/, type: 'parenthesis_korean' },
    { pattern: /^â– \s*(.+)/, type: 'bullet_square' },
    { pattern: /^â—‹\s*(.+)/, type: 'bullet_circle' },
    { pattern: /^â€»\s*(.+)/, type: 'note' },
    { pattern: /^ì œ\d+[ì¥ì ˆ]\s*(.+)/, type: 'chapter' }
  ];
  
  let currentSection = null;
  let sectionId = 0;
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    
    if (trimmedLine.length < 3) continue;
    
    for (const { pattern, type } of sectionPatterns) {
      const match = trimmedLine.match(pattern);
      if (match) {
        if (currentSection) {
          sections.push(currentSection);
        }
        
        currentSection = {
          id: `section_${sectionId++}`,
          title: match[1] || match[0],
          type: type,
          fields: []
        };
        break;
      }
    }
  }
  
  if (currentSection) {
    sections.push(currentSection);
  }
  
  return sections;
}

function identifyFields(text: string, sections: any[]): AnalyzedField[] {
  const fields: AnalyzedField[] = [];
  let fieldId = 0;
  
  // í•„ë“œ íŒ¨í„´ ì •ì˜
  const fieldPatterns = [
    // ê¸°ì—… ì •ë³´
    { pattern: /(íšŒì‚¬ëª…|ê¸°ì—…ëª…|ìƒí˜¸|ë²•ì¸ëª…|ì—…ì²´ëª…)/i, label: 'íšŒì‚¬ëª…', type: 'text', category: 'company', priority: 10 },
    { pattern: /(ëŒ€í‘œì|ëŒ€í‘œì´ì‚¬|ì„±ëª…)/i, label: 'ëŒ€í‘œìëª…', type: 'text', category: 'company', priority: 9 },
    { pattern: /(ì‚¬ì—…ì.*ë²ˆí˜¸|ë²•ì¸.*ë²ˆí˜¸)/i, label: 'ì‚¬ì—…ìë“±ë¡ë²ˆí˜¸', type: 'text', category: 'company', priority: 8 },
    { pattern: /(ë³¸ì‚¬.*ì£¼ì†Œ|ì†Œì¬ì§€|ì£¼ì†Œ|ìœ„ì¹˜)/i, label: 'íšŒì‚¬ì£¼ì†Œ', type: 'textarea', category: 'company', priority: 7 },
    { pattern: /(ì—°ë½ì²˜|ì „í™”ë²ˆí˜¸|ëŒ€í‘œì „í™”)/i, label: 'ì—°ë½ì²˜', type: 'text', category: 'company', priority: 6 },
    { pattern: /(ì´ë©”ì¼|ë©”ì¼|e-mail)/i, label: 'ì´ë©”ì¼', type: 'text', category: 'company', priority: 6 },
    { pattern: /(ì„¤ë¦½ì¼|ì„¤ë¦½ë…„ë„|ì°½ë¦½ì¼)/i, label: 'ì„¤ë¦½ì¼', type: 'date', category: 'company', priority: 5 },
    { pattern: /(ì§ì›ìˆ˜|ì¢…ì—…ì›ìˆ˜|ì¸ë ¥í˜„í™©)/i, label: 'ì§ì›ìˆ˜', type: 'number', category: 'company', priority: 5 },
    
    // ì‚¬ì—… ì •ë³´
    { pattern: /(ì‚¬ì—…ëª…|ê³¼ì œëª…|í”„ë¡œì íŠ¸.*ëª…|í”„ë¡œì íŠ¸.*ì œëª©)/i, label: 'ì‚¬ì—…ëª…', type: 'text', category: 'project', priority: 10 },
    { pattern: /(ì‚¬ì—….*ëª©ì |ì¶”ì§„.*ëª©ì |ëª©í‘œ)/i, label: 'ì‚¬ì—…ëª©ì ', type: 'textarea', category: 'project', priority: 9 },
    { pattern: /(ì‚¬ì—….*ê°œìš”|í”„ë¡œì íŠ¸.*ê°œìš”|ê³¼ì œ.*ê°œìš”)/i, label: 'ì‚¬ì—…ê°œìš”', type: 'textarea', category: 'project', priority: 9 },
    { pattern: /(ì‚¬ì—…ê¸°ê°„|ìˆ˜í–‰ê¸°ê°„|ê³¼ì œê¸°ê°„|í”„ë¡œì íŠ¸.*ê¸°ê°„)/i, label: 'ì‚¬ì—…ê¸°ê°„', type: 'text', category: 'project', priority: 8 },
    { pattern: /(ì‹œì‘.*ë‚ ì§œ|ê°œì‹œì¼|ì°©ìˆ˜ì¼)/i, label: 'ì‹œì‘ì¼', type: 'date', category: 'project', priority: 7 },
    { pattern: /(ì¢…ë£Œ.*ë‚ ì§œ|ì™„ë£Œì¼|ì¢…ë£Œì¼)/i, label: 'ì¢…ë£Œì¼', type: 'date', category: 'project', priority: 7 },
    
    // ì˜ˆì‚° ì •ë³´
    { pattern: /(ì´.*ì˜ˆì‚°|ì´.*ì‚¬ì—…ë¹„|ì „ì²´.*ì˜ˆì‚°)/i, label: 'ì´ì˜ˆì‚°', type: 'number', category: 'budget', priority: 9 },
    { pattern: /(ì§€ì›.*ê¸ˆì•¡|ì‹ ì²­.*ê¸ˆì•¡|ìš”ì²­.*ê¸ˆì•¡)/i, label: 'ì§€ì›ìš”ì²­ê¸ˆì•¡', type: 'number', category: 'budget', priority: 10 },
    { pattern: /(ìë¶€ë‹´|ìê¸°ë¶€ë‹´|ìì²´ë¶€ë‹´)/i, label: 'ìë¶€ë‹´ê¸ˆì•¡', type: 'number', category: 'budget', priority: 8 },
    { pattern: /(ì¸ê±´ë¹„)/i, label: 'ì¸ê±´ë¹„', type: 'number', category: 'budget', priority: 6 },
    { pattern: /(ì¬ë£Œë¹„|ì†Œìš”ì¬ë£Œ)/i, label: 'ì¬ë£Œë¹„', type: 'number', category: 'budget', priority: 5 },
    { pattern: /(ì¥ë¹„ë¹„|ì„¤ë¹„ë¹„)/i, label: 'ì¥ë¹„ë¹„', type: 'number', category: 'budget', priority: 5 },
    
    // ê¸°ìˆ  ì •ë³´
    { pattern: /(í•µì‹¬.*ê¸°ìˆ |ì£¼ìš”.*ê¸°ìˆ |ê¸°ìˆ .*ë‚´ìš©)/i, label: 'í•µì‹¬ê¸°ìˆ ', type: 'textarea', category: 'technology', priority: 9 },
    { pattern: /(ê¸°ìˆ .*ê°œë°œ.*ë‚´ìš©|ê°œë°œ.*ê¸°ìˆ )/i, label: 'ê¸°ìˆ ê°œë°œë‚´ìš©', type: 'textarea', category: 'technology', priority: 8 },
    { pattern: /(íŠ¹í—ˆ.*í˜„í™©|ë³´ìœ .*íŠ¹í—ˆ|ì§€ì ì¬ì‚°ê¶Œ)/i, label: 'íŠ¹í—ˆí˜„í™©', type: 'textarea', category: 'technology', priority: 7 },
    { pattern: /(ê¸°ìˆ .*ìˆ˜ì¤€|ê¸°ìˆ .*ê²½ìŸë ¥)/i, label: 'ê¸°ìˆ ìˆ˜ì¤€', type: 'textarea', category: 'technology', priority: 6 },
    
    // ì‹œì¥ ì •ë³´  
    { pattern: /(ì‹œì¥.*ë¶„ì„|ì‹œì¥.*í˜„í™©)/i, label: 'ì‹œì¥ë¶„ì„', type: 'textarea', category: 'market', priority: 8 },
    { pattern: /(ê²½ìŸì‚¬.*ë¶„ì„|ê²½ìŸ.*ì—…ì²´)/i, label: 'ê²½ìŸì‚¬ë¶„ì„', type: 'textarea', category: 'market', priority: 7 },
    { pattern: /(ëª©í‘œ.*ì‹œì¥|íƒ€ê²Ÿ.*ì‹œì¥)/i, label: 'ëª©í‘œì‹œì¥', type: 'textarea', category: 'market', priority: 7 },
    { pattern: /(ì‹œì¥.*ê·œëª¨|ì‹œì¥.*ì „ë§)/i, label: 'ì‹œì¥ê·œëª¨', type: 'textarea', category: 'market', priority: 6 },
    
    // ì¸ë ¥ ì •ë³´
    { pattern: /(ì—°êµ¬.*ì¸ë ¥|ì°¸ì—¬.*ì¸ë ¥|íŒ€.*êµ¬ì„±)/i, label: 'ì—°êµ¬ì¸ë ¥êµ¬ì„±', type: 'textarea', category: 'team', priority: 8 },
    { pattern: /(ì—°êµ¬.*ì±…ì„ì|ê³¼ì œ.*ì±…ì„ì)/i, label: 'ì—°êµ¬ì±…ì„ì', type: 'text', category: 'team', priority: 9 },
    { pattern: /(ê³µë™.*ì—°êµ¬ì|ì°¸ì—¬.*ì—°êµ¬ì)/i, label: 'ê³µë™ì—°êµ¬ì', type: 'textarea', category: 'team', priority: 7 },
    
    // ê³„íš ì •ë³´
    { pattern: /(ìˆ˜í–‰.*ê³„íš|ì¶”ì§„.*ê³„íš|ì‚¬ì—….*ê³„íš)/i, label: 'ìˆ˜í–‰ê³„íš', type: 'textarea', category: 'plan', priority: 9 },
    { pattern: /(ì¶”ì§„.*ì¼ì •|ìˆ˜í–‰.*ì¼ì •|ë‹¨ê³„ë³„.*ê³„íš)/i, label: 'ì¶”ì§„ì¼ì •', type: 'textarea', category: 'plan', priority: 8 },
    { pattern: /(ê¸°ëŒ€.*íš¨ê³¼|ì˜ˆìƒ.*ì„±ê³¼|ëª©í‘œ.*ì„±ê³¼)/i, label: 'ê¸°ëŒ€íš¨ê³¼', type: 'textarea', category: 'plan', priority: 7 },
    { pattern: /(í™œìš©.*ë°©ì•ˆ|ì‚¬ì—…í™”.*ê³„íš)/i, label: 'í™œìš©ë°©ì•ˆ', type: 'textarea', category: 'plan', priority: 6 }
  ];
  
  const lines = text.split('\n');
  
  for (const line of lines) {
    for (const fieldPattern of fieldPatterns) {
      if (fieldPattern.pattern.test(line)) {
        // ì¤‘ë³µ ì²´í¬
        const existingField = fields.find(f => f.label === fieldPattern.label);
        if (existingField) continue;
        
        const field: AnalyzedField = {
          id: `field_${fieldId++}`,
          label: fieldPattern.label,
          type: fieldPattern.type as any,
          required: fieldPattern.priority >= 8,
          category: fieldPattern.category,
          priority: fieldPattern.priority,
          description: generateFieldDescription(fieldPattern.label),
          placeholder: generatePlaceholder(fieldPattern.label, fieldPattern.type as any)
        };
        
        if (fieldPattern.type === 'text') {
          field.maxLength = determineMaxLength(fieldPattern.label);
        }
        
        fields.push(field);
      }
    }
  }
  
  return fields;
}

function categorizeFields(fields: AnalyzedField[]): AnalyzedField[] {
  return fields.sort((a, b) => {
    // ì¹´í…Œê³ ë¦¬ ìˆœì„œ
    const categoryOrder = ['company', 'project', 'budget', 'technology', 'market', 'team', 'plan'];
    const aCategoryIndex = categoryOrder.indexOf(a.category);
    const bCategoryIndex = categoryOrder.indexOf(b.category);
    
    if (aCategoryIndex !== bCategoryIndex) {
      return aCategoryIndex - bCategoryIndex;
    }
    
    // ê°™ì€ ì¹´í…Œê³ ë¦¬ ë‚´ì—ì„œëŠ” ìš°ì„ ìˆœìœ„ë¡œ ì •ë ¬
    return b.priority - a.priority;
  });
}

function addValidationRules(fields: AnalyzedField[]): AnalyzedField[] {
  return fields.map(field => {
    switch (field.label) {
      case 'ì‚¬ì—…ìë“±ë¡ë²ˆí˜¸':
        field.validation = 'business_number';
        break;
      case 'ì´ë©”ì¼':
        field.validation = 'email';
        break;
      case 'ì—°ë½ì²˜':
        field.validation = 'phone';
        break;
      case 'ì´ì˜ˆì‚°':
      case 'ì§€ì›ìš”ì²­ê¸ˆì•¡':
      case 'ìë¶€ë‹´ê¸ˆì•¡':
        field.validation = 'currency';
        break;
      case 'ì‹œì‘ì¼':
      case 'ì¢…ë£Œì¼':
      case 'ì„¤ë¦½ì¼':
        field.validation = 'date';
        break;
    }
    return field;
  });
}

function generateFieldDescription(label: string): string {
  const descriptions: Record<string, string> = {
    'íšŒì‚¬ëª…': 'ì •í™•í•œ ë²•ì¸ëª… ë˜ëŠ” ìƒí˜¸ëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš”',
    'ëŒ€í‘œìëª…': 'ëŒ€í‘œì´ì‚¬ ë˜ëŠ” ëŒ€í‘œìì˜ ì„±ëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš”',
    'ì‚¬ì—…ìë“±ë¡ë²ˆí˜¸': '000-00-00000 í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”',
    'ì‚¬ì—…ëª…': 'ì‹ ì²­í•˜ëŠ” ì‚¬ì—… ë˜ëŠ” ê³¼ì œì˜ ëª…ì¹­ì„ ì…ë ¥í•´ì£¼ì„¸ìš”',
    'ì‚¬ì—…ëª©ì ': 'ì‚¬ì—…ì„ ì¶”ì§„í•˜ëŠ” ëª©ì ê³¼ í•„ìš”ì„±ì„ êµ¬ì²´ì ìœ¼ë¡œ ê¸°ìˆ í•´ì£¼ì„¸ìš”',
    'ì´ì˜ˆì‚°': 'ì‚¬ì—…ì— ì†Œìš”ë˜ëŠ” ì „ì²´ ì˜ˆì‚°ì„ ì› ë‹¨ìœ„ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”',
    'í•µì‹¬ê¸°ìˆ ': 'ë³´ìœ í•˜ê³  ìˆê±°ë‚˜ ê°œë°œí•  í•µì‹¬ ê¸°ìˆ ì„ ìƒì„¸íˆ ê¸°ìˆ í•´ì£¼ì„¸ìš”'
  };
  
  return descriptions[label] || `${label}ì— ëŒ€í•œ ì •ë³´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”`;
}

function generatePlaceholder(label: string, type: string): string {
  if (type === 'date') {
    return 'YYYY-MM-DD';
  }
  
  const placeholders: Record<string, string> = {
    'íšŒì‚¬ëª…': 'ì˜ˆ) (ì£¼)í…Œí¬ë†€ë¡œì§€',
    'ëŒ€í‘œìëª…': 'ì˜ˆ) í™ê¸¸ë™',
    'ì‚¬ì—…ìë“±ë¡ë²ˆí˜¸': '123-45-67890',
    'ì—°ë½ì²˜': '02-1234-5678',
    'ì´ë©”ì¼': 'example@company.com',
    'ì´ì˜ˆì‚°': '100,000,000',
    'ì§ì›ìˆ˜': '15'
  };
  
  return placeholders[label] || '';
}

function determineMaxLength(label: string): number {
  const maxLengths: Record<string, number> = {
    'íšŒì‚¬ëª…': 100,
    'ëŒ€í‘œìëª…': 50,
    'ì‚¬ì—…ìë“±ë¡ë²ˆí˜¸': 12,
    'ì—°ë½ì²˜': 20,
    'ì´ë©”ì¼': 100,
    'ì‚¬ì—…ëª…': 200,
    'íšŒì‚¬ì£¼ì†Œ': 300
  };
  
  return maxLengths[label] || 500;
}

function calculateConfidence(extractedText: string, fields: AnalyzedField[], method: string): number {
  let confidence = 0.5; // ê¸°ë³¸ ì‹ ë¢°ë„
  
  // ì¶”ì¶œ ë°©ë²•ì— ë”°ë¥¸ ê°€ì¤‘ì¹˜
  switch (method) {
    case 'python-hwp5tools':
      confidence = 0.9;
      break;
    case 'libreoffice-headless':
      confidence = 0.8;
      break;
    case 'cloudconvert':
      confidence = 0.85;
      break;
    case 'convertio':
      confidence = 0.75;
      break;
    default:
      confidence = 0.5;
  }
  
  // í…ìŠ¤íŠ¸ í’ˆì§ˆì— ë”°ë¥¸ ì¡°ì •
  const koreanChars = (extractedText.match(/[ê°€-í£]/g) || []).length;
  const totalChars = extractedText.length;
  const koreanRatio = totalChars > 0 ? koreanChars / totalChars : 0;
  
  if (koreanRatio > 0.3) confidence += 0.1;
  if (koreanRatio > 0.5) confidence += 0.1;
  
  // í•„ë“œ ìˆ˜ì— ë”°ë¥¸ ì¡°ì •
  if (fields.length > 10) confidence += 0.05;
  if (fields.length > 20) confidence += 0.05;
  
  return Math.min(confidence, 1.0);
}